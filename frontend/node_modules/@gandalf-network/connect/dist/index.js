'use strict';

var graphqlRequest = require('graphql-request');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var ContentType;
(function (ContentType) {
  ContentType["Music"] = "MUSIC";
  ContentType["Shorts"] = "SHORTS";
  ContentType["Video"] = "VIDEO";
})(ContentType || (ContentType = {}));
var IdentifierType;
(function (IdentifierType) {
  IdentifierType["Asin"] = "ASIN";
  IdentifierType["Igdb"] = "IGDB";
  IdentifierType["Imdb"] = "IMDB";
  IdentifierType["Moby"] = "MOBY";
  IdentifierType["Playstation"] = "PLAYSTATION";
  IdentifierType["Rawg"] = "RAWG";
  IdentifierType["Tvdb"] = "TVDB";
  IdentifierType["Tvmaze"] = "TVMAZE";
  IdentifierType["Youtube"] = "YOUTUBE";
})(IdentifierType || (IdentifierType = {}));
var Source;
(function (Source) {
  Source["Amazon"] = "AMAZON";
  Source["Netflix"] = "NETFLIX";
  Source["Playstation"] = "PLAYSTATION";
  Source["Youtube"] = "YOUTUBE";
})(Source || (Source = {}));
/** An enum describing what kind of type a given `__Type` is. */
var __TypeKind;
(function (__TypeKind) {
  /** Indicates this type is a scalar. */
  __TypeKind["Scalar"] = "SCALAR";
  /** Indicates this type is an object. `fields` and `interfaces` are valid fields. */
  __TypeKind["Object"] = "OBJECT";
  /** Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields. */
  __TypeKind["Interface"] = "INTERFACE";
  /** Indicates this type is a union. `possibleTypes` is a valid field. */
  __TypeKind["Union"] = "UNION";
  /** Indicates this type is an enum. `enumValues` is a valid field. */
  __TypeKind["Enum"] = "ENUM";
  /** Indicates this type is an input object. `inputFields` is a valid field. */
  __TypeKind["InputObject"] = "INPUT_OBJECT";
  /** Indicates this type is a list. `ofType` is a valid field. */
  __TypeKind["List"] = "LIST";
  /** Indicates this type is a non-null. `ofType` is a valid field. */
  __TypeKind["NonNull"] = "NON_NULL";
})(__TypeKind || (__TypeKind = {}));
const GetAppByPublicKeyDocument = {
  "kind": "Document",
  "definitions": [{
    "kind": "OperationDefinition",
    "operation": "query",
    "name": {
      "kind": "Name",
      "value": "GetAppByPublicKey"
    },
    "variableDefinitions": [{
      "kind": "VariableDefinition",
      "variable": {
        "kind": "Variable",
        "name": {
          "kind": "Name",
          "value": "publicKey"
        }
      },
      "type": {
        "kind": "NonNullType",
        "type": {
          "kind": "NamedType",
          "name": {
            "kind": "Name",
            "value": "String"
          }
        }
      }
    }],
    "selectionSet": {
      "kind": "SelectionSet",
      "selections": [{
        "kind": "Field",
        "name": {
          "kind": "Name",
          "value": "getAppByPublicKey"
        },
        "arguments": [{
          "kind": "Argument",
          "name": {
            "kind": "Name",
            "value": "publicKey"
          },
          "value": {
            "kind": "Variable",
            "name": {
              "kind": "Name",
              "value": "publicKey"
            }
          }
        }],
        "selectionSet": {
          "kind": "SelectionSet",
          "selections": [{
            "kind": "Field",
            "name": {
              "kind": "Name",
              "value": "appName"
            }
          }, {
            "kind": "Field",
            "name": {
              "kind": "Name",
              "value": "gandalfID"
            }
          }]
        }
      }]
    }
  }]
};
const GetSupportedServicesDocument = {
  "kind": "Document",
  "definitions": [{
    "kind": "OperationDefinition",
    "operation": "query",
    "name": {
      "kind": "Name",
      "value": "GetSupportedServices"
    },
    "selectionSet": {
      "kind": "SelectionSet",
      "selections": [{
        "kind": "Field",
        "name": {
          "kind": "Name",
          "value": "__type"
        },
        "arguments": [{
          "kind": "Argument",
          "name": {
            "kind": "Name",
            "value": "name"
          },
          "value": {
            "kind": "StringValue",
            "value": "Source",
            "block": false
          }
        }],
        "selectionSet": {
          "kind": "SelectionSet",
          "selections": [{
            "kind": "Field",
            "name": {
              "kind": "Name",
              "value": "name"
            }
          }, {
            "kind": "Field",
            "name": {
              "kind": "Name",
              "value": "enumValues"
            },
            "arguments": [{
              "kind": "Argument",
              "name": {
                "kind": "Name",
                "value": "includeDeprecated"
              },
              "value": {
                "kind": "BooleanValue",
                "value": false
              }
            }],
            "selectionSet": {
              "kind": "SelectionSet",
              "selections": [{
                "kind": "Field",
                "name": {
                  "kind": "Name",
                  "value": "name"
                }
              }]
            }
          }]
        }
      }]
    }
  }]
};

/* eslint-disable */
/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 */
const documents = {
  "\n  query GetAppByPublicKey($publicKey: String!) {\n    getAppByPublicKey(publicKey: $publicKey) {\n        appName\n        gandalfID\n    }\n  }\n": GetAppByPublicKeyDocument,
  "\n  query GetSupportedServices {\n    __type(name: \"Source\") {\n      name\n      enumValues(includeDeprecated: false) {\n        name\n      }\n    }\n  }\n": GetSupportedServicesDocument
};
function gql(source) {
  var _a;
  return (_a = documents[source]) !== null && _a !== void 0 ? _a : {};
}

const GET_APP_BY_PUBLIC_KEY = gql(`
  query GetAppByPublicKey($publicKey: String!) {
    getAppByPublicKey(publicKey: $publicKey) {
        appName
        gandalfID
    }
  }
`);
const GET_SUPORTED_SERVICES = gql(`
  query GetSupportedServices {
    __type(name: "Source") {
      name
      enumValues(includeDeprecated: false) {
        name
      }
    }
  }
`);

const WATSON_URL = "https://sauron.gandalf.network/public/gql";
const APP_CLIP_BASE_URL = "https://appclip.apple.com/id?p=network.gandalf.connect.Clip";

const verifyPublicKey = variables => __awaiter(void 0, void 0, void 0, function* () {
  try {
    const client = new graphqlRequest.GraphQLClient(WATSON_URL);
    const data = yield client.request(GET_APP_BY_PUBLIC_KEY, variables);
    return data.getAppByPublicKey.gandalfID > 0;
  } catch (error) {
    return false;
  }
});

const base64EncodedIcon = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIj4KICAgIDxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8xMzNfMjgzOTYpIj4KICAgICAgICA8cGF0aCBkPSJNMjQgMTJDMjQgMTguNjI3NCAxOC42Mjc0IDI0IDEyIDI0QzUuMzcyNTggMjQgMCAxOC42Mjc0IDAgMTJDMCA1LjM3MjU4IDUuMzcyNTggMCAxMiAwQzE4LjYyNzQgMCAyNCA1LjM3MjU4IDI0IDEyWiIgZmlsbD0iIzY2MTBGMiI+PC9wYXRoPgogICAgICAgIDxwYXRoIGQ9Ik05LjIxODIzIDI5LjM4OTRMOC44OTYyMSAzMy43NDc0TDkuNDM2MzMgMzMuODIxNUwxMC4yOTg1IDI5LjUzNzVMOS4yMTgyMyAyOS4zODk0WiIgZmlsbD0id2hpdGUiPjwvcGF0aD4KICAgICAgICA8cGF0aCBkPSJNOS4yNTUzNiAyOS4xMTkzTDEwLjI4MDUgMTkuNjMwMUwxMS45MDA5IDE5Ljg1MjFMMTAuMzM1NiAyOS4yNjczTDkuMjU1MzYgMjkuMTE5M1oiIGZpbGw9IndoaXRlIj48L3BhdGg+CiAgICAgICAgPHBhdGggZD0iTTExLjkzNzggMTkuNTgyMUwxMC4zMTc0IDE5LjM2MDFMMTAuNDgwNCAxNC4xNTQ5TDE0LjY2ODMgMTEuNzAyM0wxMy41NzcxIDkuNjI2NzlMMTAuOTk4NSAxMC4zNzRMMTAuOTI0NSAxMC45MTQxTDExLjQ2NDYgMTAuOTg4MUwxMS45MzA3IDExLjYwMjNMMTAuODk4NSAxMy4xMTE2TDkuMDgyMDUgMTIuMzEyNUw5LjI5MzA3IDguNzY0NjNMMTQuMTgwMiA3LjIzMzIyTDE2LjgyODggMTEuOTk4M0wxMi40OTI5IDE1LjUzMTJMMTEuOTM3OCAxOS41ODIxWiIgZmlsbD0id2hpdGUiPjwvcGF0aD4KICAgICAgICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyIDIyLjY5MzNDMTcuOTA1NyAyMi42OTMzIDIyLjY5MzMgMTcuOTA1NyAyMi42OTMzIDEyQzIyLjY5MzMgNi4wOTQyNSAxNy45MDU3IDEuMzA2NyAxMiAxLjMwNjdDNi4wOTQyNSAxLjMwNjcgMS4zMDY3IDYuMDk0MjUgMS4zMDY3IDEyQzEuMzA2NyAxNy45MDU3IDYuMDk0MjUgMjIuNjkzMyAxMiAyMi42OTMzWk0xMiAyNEMxOC42Mjc0IDI0IDI0IDE4LjYyNzQgMjQgMTJDMjQgNS4zNzI1OCAxOC42Mjc0IDAgMTIgMEM1LjM3MjU4IDAgMCA1LjM3MjU4IDAgMTJDMCAxOC42Mjc0IDUuMzcyNTggMjQgMTIgMjRaIiBmaWxsPSJ3aGl0ZSI+PC9wYXRoPgogICAgPC9nPgogICAgPGRlZnM+CiAgICAgICAgPGNsaXBQYXRoIGlkPSJjbGlwMF8xMzNfMjgzOTYiPgogICAgICAgICAgICA8cmVjdCB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHJ4PSIxMCIgZmlsbD0id2hpdGUiPjwvcmVjdD4KICAgICAgICA8L2NsaXBQYXRoPgogICAgPC9kZWZzPgo8L3N2Zz4K';
const qrCodeStyle = url => {
  return {
    width: 300,
    height: 300,
    data: url,
    margin: 0,
    qrOptions: {
      typeNumber: 0,
      mode: "Byte",
      errorCorrectionLevel: "Q"
    },
    imageOptions: {
      hideBackgroundDots: true,
      imageSize: 0.5,
      margin: 4
    },
    dotsOptions: {
      type: "classy",
      color: "#6610f3"
    },
    backgroundOptions: {
      color: "#ffffff"
    },
    image: base64EncodedIcon,
    cornersDotOptions: {
      color: "#6a0ff3"
    },
    cornersSquareOptions: {
      type: "extra-rounded",
      color: "#6610f3"
    }
  };
};

const getSupportedServices = () => __awaiter(void 0, void 0, void 0, function* () {
  var _a;
  let services = [];
  try {
    const client = new graphqlRequest.GraphQLClient(WATSON_URL);
    const data = yield client.request(GET_SUPORTED_SERVICES);
    if ((_a = data.__type) === null || _a === void 0 ? void 0 : _a.enumValues) {
      for (let i of data.__type.enumValues) {
        services = [...services, i.name.toLowerCase()];
      }
    }
    return services;
  } catch (error) {
    return services;
  }
});

var GandalfErrorCode;
(function (GandalfErrorCode) {
  GandalfErrorCode["InvalidPublicKey"] = "INVALID_PUBLIC_KEY";
  GandalfErrorCode["InvalidRedirectURL"] = "INVALID_REDIRECT_URL";
  GandalfErrorCode["InvalidService"] = "INVALID_SERVICE";
  GandalfErrorCode["DataKeyNotFound"] = "DATA_KEY_NOT_FOUND";
  GandalfErrorCode["QRCodeNotGenerated"] = "QR_CODE_NOT_GENERATED";
  GandalfErrorCode["QRCodeGenNotSupported"] = "QR_CODE_GEN_NOT_SUPPORTED";
})(GandalfErrorCode || (GandalfErrorCode = {}));
class GandalfError extends Error {
  constructor(message, code) {
    super(message);
    Object.setPrototypeOf(this, GandalfError.prototype);
    this.name = "GandalfError";
    this.code = code;
  }
}

let QRCodeStyling;
if (typeof window !== 'undefined') {
  import('qr-code-styling').then(module => {
    QRCodeStyling = module.default;
  });
}
class Connect {
  constructor(input) {
    this.verificationComplete = false;
    if (input.redirectURL.endsWith('/')) {
      input.redirectURL = input.redirectURL.slice(0, -1);
    }
    this.publicKey = input.publicKey;
    this.redirectURL = input.redirectURL;
    this.services = input.services;
  }
  generateURL() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.allValidations(this.publicKey, this.redirectURL, this.services);
      const services = JSON.stringify(this.services);
      return encodeURI(`${APP_CLIP_BASE_URL}&services=${services}&redirectUrl=${this.redirectURL}&publicKey=${this.publicKey}`);
    });
  }
  generateQRCode() {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof window == 'undefined') {
        throw new GandalfError("QrCode generation only works in browsers", GandalfErrorCode.QRCodeGenNotSupported);
      }
      yield this.allValidations(this.publicKey, this.redirectURL, this.services);
      const services = JSON.stringify(this.services);
      const url = encodeURI(`${APP_CLIP_BASE_URL}&services=${services}&redirectUrl=${this.redirectURL}&publicKey=${this.publicKey}`);
      const qrCode = new QRCodeStyling(qrCodeStyle(url));
      try {
        const qrCodeBlob = yield qrCode.getRawData('webp');
        if (!qrCodeBlob) {
          throw new GandalfError("QRCode Generation Error", GandalfErrorCode.QRCodeNotGenerated);
        }
        const qrCodeURL = URL.createObjectURL(qrCodeBlob);
        return qrCodeURL;
      } catch (error) {
        throw new GandalfError(error.message, GandalfErrorCode.QRCodeNotGenerated);
      }
    });
  }
  static getSupportedServices() {
    return __awaiter(this, void 0, void 0, function* () {
      const services = yield getSupportedServices();
      return services;
    });
  }
  static getDataKeyFromURL(redirectURL) {
    Connect.validateRedirectURL(redirectURL);
    const url = new URL(redirectURL);
    const dataKey = url.searchParams.get('dataKey');
    if (!dataKey) {
      throw new GandalfError(`Datakey not found in the URL ${redirectURL}`, GandalfErrorCode.DataKeyNotFound);
    }
    return dataKey;
  }
  allValidations(publicKey, redirectURL, services) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.verificationComplete) {
        yield Connect.validatePublicKey(publicKey);
        yield Connect.validateInputServices(services);
        Connect.validateRedirectURL(redirectURL);
      }
      this.verificationComplete = true;
    });
  }
  static validatePublicKey(publicKey) {
    return __awaiter(this, void 0, void 0, function* () {
      const isValidPublicKey = yield verifyPublicKey({
        publicKey
      });
      if (!isValidPublicKey) {
        throw new GandalfError('Public key does not exist', GandalfErrorCode.InvalidPublicKey);
      }
    });
  }
  static validateInputServices(input) {
    return __awaiter(this, void 0, void 0, function* () {
      const services = yield getSupportedServices();
      let unsupportedServices = [];
      let requiredServices = 0;
      for (const key in input) {
        if (!services.includes(key.toLowerCase())) {
          unsupportedServices = [...unsupportedServices, key];
          continue;
        }
        if (input[key]) requiredServices++;
      }
      if (unsupportedServices.length > 0) {
        throw new GandalfError(`These services ${unsupportedServices.join(' ')} are unsupported`, GandalfErrorCode.InvalidService);
      }
      if (requiredServices < 1) {
        throw new GandalfError("At least one service has to be required", GandalfErrorCode.InvalidService);
      }
    });
  }
  static validateRedirectURL(url) {
    try {
      Boolean(new URL(url));
    } catch (e) {
      throw new GandalfError('Invalid redirectURL', GandalfErrorCode.InvalidRedirectURL);
    }
  }
}

module.exports = Connect;
